// Preamble for SXrdClasses.cxx, generated by the extract-sxrd-classes.pl script.

#include "SXrdClasses.h"
#include "TMath.h"
#include "TTree.h"

void dump_xrdfar_tree_ioinfo(TTree *t, Long64_t ev)
{
  if (ev < 0 || ev >= t->GetEntriesFast())
  {
    fprintf(stderr, "Error, event %lld out of range (max=%lld).\n",
	    ev, t->GetEntriesFast());
    return;
  }

  SXrdIoInfo *xp = 0;
  t->SetBranchAddress("I.", &xp);
  if (xp == 0)
  {
    fprintf(stderr, "Error, branch with detailed info not found.\n",
	    ev, t->GetEntriesFast());
    return;
  }


  t->GetEntry(ev);

  xp->Dump(2);
}


//==============================================================================
// $Id: SRange.cxx 2931 2014-01-23 22:25:55Z matevz $

// Copyright (C) 1999-2008, Matevz Tadel. All rights reserved.
// This file is part of GLED, released under GNU General Public License version 2.
// For the licensing terms see $GLEDSYS/LICENSE or http://www.gnu.org/.

//__________________________________________________________________________
// SRange
//
//

//#include "SRange.h"

//#include <TMath.h>

ClassImp(SRange);

//==============================================================================

SRange::SRange()
{
  Reset();
}

void SRange::Reset()
{
  mMin = mMax = mSumX = mSumX2 = 0;
  mN = 0;
}

void SRange::Reset(Double_t min, Double_t max, Double_t sumx, Double_t sumx2, ULong64_t n)
{
  mMin  = min;  mMax   = max;
  mSumX = sumx; mSumX2 = sumx2;
  mN    = n;
}

void SRange::SetSumX2FromSigma(Double_t sigma)
{
  if (mN > 0)
    mSumX2 = mN*sigma*sigma + mSumX*mSumX/mN;
  else
    mSumX2 = 0;
}

//------------------------------------------------------------------------------

void SRange::AddSample(Double_t x)
{
  if (mN == 0) {
    mMin = mMax = x;
  } else {
    if (x < mMin) mMin = x;
    if (x > mMax) mMax = x;
  }
  mSumX  += x;
  mSumX2 += x*x;
  ++mN;
}

//------------------------------------------------------------------------------

Double_t SRange::GetAverage() const
{
  if (mN > 0)
    return mSumX / mN;
  else
    return 0;
}

Double_t SRange::GetSigma() const
{
  if (mN > 0)
    return TMath::Sqrt((mSumX2 - mSumX*mSumX/mN)/mN);
  else
    return 0;
}

//------------------------------------------------------------------------------

void SRange::Dump(const TString& prefix, const TString& postfix) const
{
  printf("%s%5lld : (%10.3f, %10.3f, %10.3f) : %10.3f%s",
         prefix.Data(),
         mN, mMin, GetAverage(), mMax, GetSigma(),
         postfix.Data());
}


//==============================================================================
// $Id: SXrdIoInfo.cxx 2936 2014-01-28 22:57:02Z matevz $

// Copyright (C) 1999-2008, Matevz Tadel. All rights reserved.
// This file is part of GLED, released under GNU General Public License version 2.
// For the licensing terms see $GLEDSYS/LICENSE or http://www.gnu.org/.

//#include "SXrdIoInfo.h"

//==============================================================================
// SXrdIoInfo
//==============================================================================

//______________________________________________________________________________
//
//

void SXrdIoInfo::Dump(Int_t level)
{
  printf("SXrdIoInfo::Dump() N_reqs = %zu, N_vec_read_subreqs = %zu, N_errors = %d\n",
	 mReqs.size(), mOffsetVec.size(), mNErrors);

  if (level <= 0) return;

  int cnt = 0;
  for (vSXrdReq_i i = mReqs.begin(); i != mReqs.end(); ++i, ++cnt)
  {
    printf("%4d  %-7s ", cnt, i->TypeName());
    switch (i->Type())
    {
      case SXrdReq::R_Write:
      {
	printf("t=%-5d l=%-9d o=%lld\n", i->Time(), -i->Length(), i->Offset());
	break;
      }
      case SXrdReq::R_Read:
      {
	printf("t=%-5d l=%-9d o=%lld\n", i->Time(),  i->Length(), i->Offset());
	break;
      }
      case SXrdReq::R_VecRead:
      {
	Int_t sr_idx = i->SubReqIndex();

	printf("t=%-5d l=%-9d n_req_cnt=%-5hu n_reqs_lost=%-5hu idx=%d\n",
	       i->Time(), i->Length(), i->SubReqCount(), i->SubReqsLost(),
	       sr_idx);

	if (level > 1 && sr_idx >= 0)
	{
	  Int_t max = sr_idx + i->SubReqsStored();
	  Int_t j   = 0;
	  for (Int_t si = i->SubReqIndex(); si < max; ++si, ++j)
	  {
	    printf("             i=%-5d l=%-9d o=%lld\n", j, mLengthVec[si], mOffsetVec[si]);
	  }
	}
	break;
      }
    }
  }
}

//==============================================================================
// SXrdIoReq
//==============================================================================

//______________________________________________________________________________
//
//
